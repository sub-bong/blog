---
title: "배열과 any 타입"
date: "2025-09-09"
keywords: ["TIL", "Typescript"]
---

# 배열과 any 타입

## 1. 배열 (Array)

타입스크립트에서 배열의 타입을 지정하는 방법은 두 가지가 있습니다.

### 방법 1: `타입[]`

가장 일반적으로 사용되는 방법으로, 배열의 요소가 특정 타입임을 나타냅니다.

```typescript
// string 타입의 요소로만 구성된 배열
let fruits: string[] = ["Apple", "Banana", "Cherry"];

// number 타입의 요소로만 구성된 배열
let scores: number[] = [100, 90, 85];

// 다른 타입의 요소를 추가하면 오류가 발생합니다.
// scores.push("70"); // Error: 'string' 형식의 인수는 'number' 형식의 매개 변수에 할당될 수 없습니다.
```

### 방법 2: `Array<타입>` (제네릭 문법)

제네릭(Generic) 문법을 사용하여 배열의 타입을 지정할 수도 있습니다.

```typescript
// string 타입의 요소로만 구성된 배열
let fruits: Array<string> = ["Apple", "Banana", "Cherry"];

// number 타입의 요소로만 구성된 배열
let scores: Array<number> = [100, 90, 85];
```

두 방법은 기능적으로 동일하며, 어떤 것을 사용할지는 개인이나 팀의 코딩 스타일에 따라 선택합니다.

타입스크립트는 타입 추론을 통해 초기화된 배열의 타입을 자동으로 인식하기도 합니다.

```typescript
// a는 number[] 타입으로 추론됩니다.
const a = [1, 2, 3];
```

## 2. `any` 타입

`any` 타입은 타입 검사를 받지 않고 어떤 타입의 값이든 될 수 있음을 의미합니다. 타입스크립트의 정적 타입 검사 장점을 포기하는 것과 같으므로, 사용을 최소화해야 합니다.

- **`any` 타입의 특징**:
  - 모든 타입의 값을 할당할 수 있습니다.
  - `any` 타입의 변수는 어떤 타입의 변수에도 할당할 수 있습니다.
  - 타입 검사기가 오류를 확인하지 않으므로, 존재하지 않는 속성이나 메서드에 접근해도 컴파일 오류가 발생하지 않습니다. (런타임 오류의 원인이 됨)

```typescript
let obj: any = { x: 0 };

// 아래 코드는 모두 컴파일 오류를 발생시키지 않습니다.
obj.foo();
obj();
obj.bar = 100;
obj = "hello";
const n: number = obj;
```

- **`any` 타입의 사용 시점**:
  - 개발 단계에서 임시로 타입을 정하기 어려울 때
  - 타입 정보를 알 수 없는 외부 라이브러리나 API의 값을 받아올 때

`any`를 남용하면 타입스크립트를 사용하는 의미가 퇴색되므로, 꼭 필요한 경우가 아니라면 `unknown`과 같은 더 안전한 타입을 사용하는 것이 좋습니다.
